.\"	$OpenBSD$
.\"
.\" Copyright (c) 2017 Kristaps Dzonsons <kristaps@bsd.lv>
.\"
.\" Permission to use, copy, modify, and distribute this software for any
.\" purpose with or without fee is hereby granted, provided that the above
.\" copyright notice and this permission notice appear in all copies.
.\"
.\" THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
.\" WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
.\" MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
.\" ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
.\" WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
.\" ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
.\" OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
.\"
.Dd $Mdocdate$
.Dt KWEBAPP 1
.Os
.Sh NAME
.Nm kwebapp
.Nd create web application API and database layer
.Sh SYNOPSIS
.Nm kwebapp
.Op Fl F Ar options
.Op Fl O Ar output
.Op Ar header|oldconfig
.Op Ar config
.Sh DESCRIPTION
The
.Nm
utility accepts a configuration file
.Ar config
.Pq defaulting to standard input
and creates source files:
.Bl -bullet
.It
C API to the database (see
.Fl O Ns Ar csource
and
.Fl O Ns Ar cheader ) ;
and optionally, the API from data objects to JSON output and field input
validation functions (see
.Fl F Ns Ar json
and
.Fl F Ns Ar valids )
.It
SQL defining the database itself (see
.Fl O Ns Ar sql )
.It
SQL defining the difference between configuration versions (painless
updating of database schema) (see
.Fl O Ns Ar sqldiff )
.It
JavaScript for filling in DOM trees with data given by
.Fl F Ns Ar json
(see
.Fl O Ns Ar javascript )
.El
.Pp
These reduce the often-repeated code of serialising and de-serialising
structures from a database into a web application.
.Pp
By default, it parses the configuration file for errors
.Pq see Fl O Ns Ar none
Its arguments are as follows:
.Bl -tag -width Ds
.It Fl F Ar options
Options when producing output.
Choices are
.Fl F Ns Ar json ,
to produce JSON output functions in
.Fl O Ns Ar csource
and
.Fl O Ns Ar cheader
output (requires linking to
.Xr kcgijson 3 ) ;
and
.Fl F Ns Ar valids
to produce
.Xr kcgi 3
validation functions in
.Fl O Ns Ar csource
and
.Fl O Ns Ar cheader
output (requires linking to
.Xr kcgi 3 ) .
The
.Fl F Ns Ar splitproc
choice causes
.Fl O Ns Ar csource
and
.Fl O Ns Ar cheader
to use a split-process database model (see
.Xr ksql_alloc_child 3 ) .
.It Fl O Ar output
Choose the type of output.
Choices are
.Fl O Ns Ar csource
for the
.Sx C source ,
.Fl O Ns Ar cheader
for the
.Sx C header ,
.Fl O Ns Ar javascript
for the
.Sx JavaScript
front-end code,
.Fl O Ns Ar none
for not producing output (validation only),
.Fl O Ns Ar sql
for the
.Sx SQL schema ,
and
.Fl O Ns Ar sqldiff
for the
.Sx SQL update
sequence that updates an old configuration file's schema.
.It Ar header|oldconfig
If
.Fl O Ns Ar csource
is specified, the
.Ar header
is required for the header file (see
.Fl O Ns Ar cheader ) .
If
.Fl O Ns Ar sqldiff
is specified, the
.Ar oldconfig
is required for the prior configuration to differentiate.
.It Ar config
A configuration file in the
.Xr kwebapp 5
format.
.El
.Pp
In all instances (except for
.Fl O Ns Ar none ) ,
the generated file is produced on standard output.
See the
.Sx EXAMPLES
section for a full run-through of functionality.
.Ss C header
The C header file generated by
.Nm
lists all structures and functions defined by
.Ar config .
Sources including the header will need only the
.Xr ksql 3
requirements, and possibly queue macros:
.Bd -literal -offset indent
#include <sys/queue.h> /* if you have lists */
#include <stdint.h> /* ksql(3) */
#include <ksql.h>
.Ed
.Pp
If you have
.Fl F Ns Ar valids
specified, you'll also need to pull in
.Xr kcgi 3
headers:
.Bd -literal -offset indent
#include <sys/queue.h> /* if you have lists */
#include <sys/types.h> /* kcgi(3) */
#include <stdarg.h> /* kcgi(3) */
#include <stddef.h> /* kcgi(3) */
#include <stdint.h> /* kcgi(3) and ksql(3) */
#include <kcgi.h>
#include <ksql.h>
.Ed
.Pp
And lastly, if you have
.Fl F Ns Ar json ,
you'll also need
.Xr kcgijson 3 :
.Bd -literal -offset indent
#include <sys/queue.h> /* if you have lists */
#include <sys/types.h> /* kcgi(3) */
#include <stdarg.h> /* kcgi(3) */
#include <stddef.h> /* kcgi(3) */
#include <stdint.h> /* kcgi(3) and ksql(3) */
#include <kcgi.h>
#include <kcgijson.h>
#include <ksql.h>
.Ed
.Pp
If you have roles specified in
.Ar config ,
the header file will include all roles within an
.Vt enum kwbp_role ,
with each role name prefixed with
.Li ROLE .
The special empty and default roles,
.Li ROLE_none
and
.Li ROLE_default ,
are also specified.
.Pp
For each enumeration object in
.Ar config ,
.Nm
generates a C
.Dq enum
with the name as the enumeration's unique name.
The enumeration is then given a series of values for each item in the
enumeration object.
These are prefixed with the capitalised enumeration name, followed by an
underscore, followed by the item name.
For example, if the enumeration is named
.Dq foo
and the item is named
.Dq bar ,
the enumeration value will be
.Dq FOO_bar .
The enumeration constant is defined to be the item's value.
So a value of 5 for the given item would produce
.Dq FOO_bar = 5 .
.Pp
For each structure object in
.Ar config ,
.Nm
generates a C
.Dq struct
by that name containing all typed fields.
Moreover, if any of the fields are defined with
.Cm null ,
an additional field of
.Va has_xxxx
is defined, where
.Dq xxxx
is the name of the field.
This field will be non-zero if the field was not null during access;
otherwise it will be zero.
If any fields are defined as enumerations, they will be given the
enumeration type.
.Pp
If there are any list statements on the object, the structure has
queue macros created for it as well.
If there are any iterator statements, the function callback types are
also generated.
.Pp
For the following functions, the first argument is either
.Vt struct ksql
or
.Vt struct kwbp ,
with the latter
.Dq hiding
the database connection in the event of any roles.
In this list, let
.Dq foo
to be the name of a sample structure object:
.Bl -tag -width Ds
.It Fn db_foo_delete_xxxx
Run the named delete function
.Dq xxxx .
The delete functions are specified with
.Cm delete
statements.
The parameters passed to this function are
the fields that constrain which rows are deleted.
Parameters are only specified for operations for binary-operator
constraints, i.e., those not checking for null status.
.It Fn db_foo_delete_by_yy_op
Like
.Fn db_foo_delete_xxxx ,
but using an un-named delete statement constrained by
.Dq yy
with operation
.Dq op .
.It Fn db_foo_fill
Zero and fill in a pointer from an open database query.
This fills all nested structures as well.
.It Fn db_foo_free
Frees a pointer returned by a unique search function.
.It Fn db_foo_freeq
Frees a queue (and its members) created by a listing function.
This function is produced only if there are listing statements on a
given structure.
.It Fn db_foo_get_xxxx
If the structure object has any named searches, these are listed in
place of the
.Dq xxxx .
The function accepts variables for all binary-operator fields to check
(i.e., all except for those checking for null).
.It Fn db_foo_get_by_xxxx_op1_yy_zz_op2
Like
.Fn db_foo_get_xxxx ,
but for (possibly-nested) structures.
In the given example,
.Dq xxxx
is a field in the given structure with operation
.Dq op1
and
.Dq yy_zz
means a field
.Dq zz
in the nested structure
.Dq yy
with operation
.Dq op2 .
.It Fn db_foo_insert
Insert a row and return its identifier.
This accepts all native fields as parameters excluding
.Cm rowid ,
which is automatically set by the database.
If any fields are specified as
.Cm null ,
they are passed into this functions as pointers.
The null values must then be specified as
.Dv NULL
pointers.
This function is only generated if the
.Cm insert
statement is specified for the given structure.
.It Fn db_foo_iterate
Iterate over all rows.
.It Fn db_foo_iterate_xxxx
Like
.Fn db_foo_get_xxxx ,
but invoking a function callback within the active query for each
retrieved result.
.It Fn db_foo_iterate_by__xxxx_op1__yy_zz_op2
Like
.Fn db_foo_get_by__xxxx_op1__yy_zz_op2 ,
but invoking a function callback for the retrieved results.
.It Fn db_foo_list
Get a queue of all rows.
.It Fn db_foo_list_xxxx
Like
.Fn db_foo_get_xxxx ,
but producing a queue of responses.
.It Fn db_foo_list_by__xxxx_op1__yy_zz_op2
Like
.Fn db_foo_get_by__xxxx_op1__yy_zz_op2 ,
but producing a queue of responses.
.It Fn db_foo_unfill
Release resources filled from a database query.
This frees all nested structures as well.
.It Fn db_foo_update_xxxx
Run the named update function
.Dq xxxx .
The update functions are specified with
.Cm update
statements.
The parameters passed to this function are first the fields to modify,
then the fields that constrain which rows are updated.
If any modified fields are specified as
.Cm null ,
they are passed into this functions as pointers.
Any null values must then be specified as
.Dv NULL
pointers.
Update fields are only specified for operations for binary-operator
constraints, i.e., those not checking for null status.
.It Fn db_foo_update_xx_by_yy_op
Like
.Fn db_foo_update_xxxx ,
but using an un-named update statement modifying
.Dq xx
constrained by
.Dq yy
with operation
.Dq op .
.El
.Pp
There are also several convenience functions for the database:
.Bl -tag -width Ds
.It Fn db_open
Open a database in
.Dq safe exit
mode as documented in
.Xr ksql 3 .
If
.Fl F Ns Ar splitproc
is specified, this uses the split-process model.
Also installs the default logging facilities.
.It Fn db_close
Closes a database opened by
.Fn db_open .
.El
.Pp
If the
.Fl F Ns Ar json
flag was specified, JSON-specific functions are also generated for each
structure object.
If you use this flag, you'll need to link with
.Xr kcgijson 3 ,
as they use the
.Vt "struct kjsonreq"
for formatting JSON.
Given the same structure
.Dq foo ,
the following are generated:
.Bl -tag -width Ds
.It Fn json_foo_array
Print the list of structure as a key-value pair where the key is the
structure name and the value is an array consisting of
.Fn json_foo_data
objects.
This is only produced if the structure has
.Cm list
queries stipulated.
.It Fn json_foo_data
Enumerate only the fields of the structure in JSON dictionary format.
The key is the field name and the value is a string for text types,
decimal number for reals, integer for integers, and base64-encoded
string for blobs.
If a field is null, it is serialised as a null value.
Fields marked
.Cm noexport
are not included in the enumeration, nor are passwords.
.It Fn json_foo_iterate
Print a "blank" object consisting only of the structure data (see
.Fn json_foo_data )
within JSON object braces.
The calling convention (passing a
.Vt "void *"
as the
.Vt "struct kjsonreq" )
makes for easy integration with iterate functions.
This is only produced if the structure has
.Cm iterate
queries stipulated.
.It Fn json_foo_obj
Print the entire structure as a key-value pair where the key is the
structure name and the value is an object consisting of
.Fn json_foo_data .
.El
.Pp
If the
.Fl F Ns Ar valids
flag was specified, field input validation functions are generated.
A full validation array is given for all fields, although these need not
be used by the calling application.
You'll need to link with
.Xr kcgi 3 .
Given the same structure
.Dq foo ,
the following are generated:
.Bl -tag -width Ds
.It Fn valid_foo_xxxx
Validate the field
.Dq xxxx
in the structure.
This should be used in place of raw validation functions such as
.Xr kvalid_int 3 .
The validation function will at least validate the type.
If limitation clauses are given to a field, those will also be emitted
within this function.
.Em Note :
structs are not validated.
.It Vt enum valid_keys
An enumeration of all fields that accept validators.
The enumeration entries are VALID_FOO_XXXX, where
.Dq XXXX
is the field name.
The last enumeration value is always
.Dv VALID__MAX .
.It Vt const struct kvalid valid_keys[VALID__MAX]
A validation array for
.Xr khttp_parse 3 .
This uses the
.Fn valid_foo_xxxx
functions as described above and names corresponding HTML form entries
as
.Dq foo-xxxx ,
where again,
.Dq xxxx
is the field name.
.El
.Pp
All of these are fully documented in the header file.
The structures are documented using the comments given in
.Ar config .
.Ss C source
A series of function definitions for the
.Sx C header .
This is internally documented to assist the reader.
It will compile with any modern ANSI C compiler.
.Ss SQL schema
Emits a series of
.Cm CREATE TABLE
SQL commands representing the objects in
.Ar config .
These encapsulate the foreign keys and all other required SQL
attributes.
The SQL generated is designed for
.Xr sqlite3 1 .
.Ss SQL update
Emits a series of
.Cm CREATE TABLE
and
.Cm ALTER TABLE
SQL commands to update the configuration
.Ar oldconfig
to the new configuration
.Ar config .
.Pp
The configuration files are considered incompatible if they contain
destructive differences: dropped objects (structures or fields) or
different fields (types, references, attributes).
.Pp
The SQL generated is designed for
.Xr sqlite3 1 .
.Ss JavaScript
Emits a standards-compliant JavaScript file filling JSON output (with
.Fl F Ns Ar json )
into a DOM tree, usually acquired from an AJAX request to the web
application.
(This process is not managed by
.Nm . )
.Pp
To use the interface, simply include the generated file as a script,
create objects given the JSON output of
.Fl F Ns Ar json ,
and invoke the object's
.Fn fill ,
.Fn fillInner ,
and
.Fn fillArray
methods with the DOM tree node.
Given a structure
.Dq foo
and an AJAX response
.Dq response ,
this might look like:
.Bd -literal -offset indent
var obj = JSON.parse(response);
var e = document.getElementById('foo');
new foo(obj).fill(e);
.Ed
.Pp
For each field in the structure, this method will operate on elements
within (and including) the element with id
.Dq foo
having classes as follows:
.Bl -tag -width Ds
.It Li foo-xxxx-text
Replaces the contents of the element with the field value.
This is only applicable for non-blob native types.
.It Li foo-xxxx-value
Sets the
.Dq value
attribute (as in a form submission) with the field value.
This is only applicable for non-blob native types.
.It Li foo-has-xxxx
Remove the
.Dq hide
class if the object is null, otherwise add the
.Dq hide
class.
.It Li foo-no-xxxx
Add the
.Dq hide
class if the object is null, otherwise remove the
.Dq hide
class.
.It Li foo-xxxx-obj
For structures, creates and invokes the
.Fn fillInner
method on the nested structure at the given element and its descendents.
This is only applicable for structure types.
.El
.Pp
Alternatively, the
.Fn fillInner
method may be used to exclude the root element.
Lastly, the
.Fn fillArray
method invokes
.Fn fill
repeatedly over an array of objects by removing, then subsequently
cloning and appending the first element of the give DOM root.
.Pp
All functions accept an additional, optional argument for providing
custom per-field callbacks.
Assuming a structure
.Dq client
with a field
.Dq dob
consisting of a UNIX epoch:
.Bd -literal -offset indent
var custom = { 'client-dob': formatDate };
new client(obj).fill(e, custom);
.Ed
.Pp
And letting a formatting function be:
.Bd -literal -offset indent
function formatDate(e, name, txt)
{
  var list, i;
  list = e.getElementsByClassName('client-dob-date');
  for (i = 0; i < list.length; i++) 
    list[i].innerHTML = 
      moment.unix(txt).format('DD-MM-YYYY'));
}
.Ed
.Pp
This invokes the
.Dq moment.js
formatter to create dates.
.Pp
The JavaScript methods and variables are fully documented in the
.Xr jsdoc 1
format.
.\" The following requests should be uncommented and used where appropriate.
.\" .Sh CONTEXT
.\" For section 9 functions only.
.\" .Sh RETURN VALUES
.\" For sections 2, 3, and 9 function return values only.
.\" .Sh ENVIRONMENT
.\" For sections 1, 6, 7, and 8 only.
.\" .Sh FILES
.Sh EXIT STATUS
.\" For sections 1, 6, and 8 only.
.Ex -std
.Pp
In the case of
.Fl d ,
exiting >0 means that
.Ar oldconfig
and
.Ar config
are incompatible.
.Sh EXAMPLES
Given a data layer defined in
.Pa db.txt ,
the following produce all of the code necessary for a web application to
manipulate and output its data:
.Bd -literal  -offset indent
$ kwebapp -Ocheader -Fjson db.txt >extern.h
$ kwebapp -Ocsource -Fjson extern.h db.txt >db.c
.Ed
.Pp
Assuming a
.Xr kcgi 3
and
.Xr ksql 3
web application
.Pa main.c
that interfaces with
.Pa extern.h ,
the following compiles the application.
.Bd -literal -offset indent
cc -c -o db.o db.c
cc -c -o main.o main.c
cc -o cgi db.o main.o -lksql -lsqlite3 -lkcgijson -lkcgi -lz
.Ed
.Pp
The first two libraries are needed for the database component via
.Xr ksql 3
and its library dependencies;
the latter, for the JSON output component via
.Xr kcgijson 3 .
.\" .Sh DIAGNOSTICS
.\" For sections 1, 4, 6, 7, 8, and 9 printf/stderr messages only.
.\" .Sh ERRORS
.\" For sections 2, 3, 4, and 9 errno settings only.
.Sh SEE ALSO
.Xr jsdoc 1 ,
.Xr kcgi 3 ,
.Xr kcgijson 3 ,
.Xr ksql 3 ,
.Xr kwebapp 5
.\" .Sh STANDARDS
.\" .Sh HISTORY
.\" .Sh AUTHORS
.\" .Sh CAVEATS
.\" .Sh BUGS
