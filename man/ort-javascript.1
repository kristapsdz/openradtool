.\"	$OpenBSD$
.\"
.\" Copyright (c) 2017--2020 Kristaps Dzonsons <kristaps@bsd.lv>
.\"
.\" Permission to use, copy, modify, and distribute this software for any
.\" purpose with or without fee is hereby granted, provided that the above
.\" copyright notice and this permission notice appear in all copies.
.\"
.\" THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
.\" WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
.\" MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
.\" ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
.\" WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
.\" ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
.\" OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
.\"
.Dd $Mdocdate$
.Dt ORT-JAVASCRIPT 1
.Os
.Sh NAME
.Nm ort-javascript
.Nd produce ort TypeScript interface
.Sh SYNOPSIS
.Nm ort-javascript
.Op Ar config...
.Sh DESCRIPTION
The
.Nm
utility accepts
.Xr ort 5
.Ar config
files, defaulting to standard input,
and creates a TypeScript interface that format the JSON produced by
.Xr ort-c-header 1
.Fn json_xxxx
functions.
.Pp
Output consists of the
.Qq ort
namespace with classes that fill data from the JSON into a DOM tree by
operating on elements having specific classes.
.Pp
The output of
.Nm
is fully documented using TypeDoc annotation.
.Ss Namespaces
All data produced by
.Nm
is contained within a namespace
.Qq ort .
For example, let
.Qq foo
be a
.Cm struct
defined in the configuration.
.Bd -literal -offset indent
namespace ort {
  export interface DataCallbacks { ... }
  export interface fooData { ... }
  export class foo { ... }
}
.Ed
.Ss Interfaces
Each
.Cm struct
in the configuration is rendered as a TypeScript interface suffixed
.Qq Data ,
for example,
.Qq fooData
for a structure named
.Qq foo .
Each native field is mapped to a native type:
.Cm string
or
.Cm number .
For references, the type is the referenced interface type.
.Bd -literal -offset indent
namespace ort {
  export interface fooData {
    sometext: string;
    somenumber: number;
    areference: barData;
  }
}
.Ed
.Pp
In addition to this, a
.Qq DataCallbacks
interface may be used for
.Sx Customisation
and contains callback functions for each field for formatting purposes.
.Ss Constructors
Structures are output as classes containing formatting methods.
(Enumerations and bitfields have static classes.)
They are named as found in the configuration.
Each structure has a constructor to which one passes a single object of
the given interface type or an array of interfaces.
In this example, let
.Fa parseData
create the required interfaces.
.Bd -literal -offset indent
let input: ort.fooData = parseData();
let foo: ort.foo = new ort.foo(input);
.Ed
.Pp
The array may be zero-length, but the object may not be
.Dv null .
.Ss Class Methods
The following methods are generated for each structure.
.Bl -tag -width Ds -offset indent
.It Fn fillInner "e" "[custom]"
Fill labelled elements within (but not including) element
.Fa e ,
with optional call-backs
.Fa custom .
If
.Fa e
is
.Dv null ,
does nothing.
.It Fn fillInnerByClass "e" "className" "[custom]"
Convenience method for invoking
.Fn fillInner
over all descendents of element
.Fa e
having class
.Fa className .
If
.Fa e
is
.Dv null ,
does nothing.
The
.Qq inner
applies to both
.Fa e
and the matched descendents.
.It Fn fill "e" "[custom]"
Fill labelled elements within (including) element
.Fa e ,
with optional call-backs
.Fa custom .
If
.Fa e
is
.Dv null ,
does nothing.
.It Fn fillByClass "e" "className" "[custom]"
Convenience method for invoking
.Fn fill
over all descendents of (and including) element
.Fa e
having class
.Fa className .
If
.Fa e
is
.Dv null ,
does nothing.
.It Fn fillArray "e" "[custom]"
First hides (appends the
.Qq hide
class)
.Fa e ,
then invokes
.Fn fill
repeatedly over the objects (or standalone object) passed at
construction time by removing, then subsequently cloning and appending,
the first element of
.Fa e .
The
.Fn fill
function is passed the new element's root and
.Fa custom .
If
.Fa e
is
.Dv null
or empty, does nothing except add the
.Qq hide
class to
.Fa e .
.It Fn fillArrayOrShow "e" "toshow" "[custom]"
Convenience method around
.Fa fillArray ,
showing (remove the
.Qq hide
class)
.Fa toshow
if the object or objects at construction are non-empty.
.It Fn fillArrayOrHide "e" "tohide" "[custom]"
Convenience method around
.Fa fillArray ,
hiding (append the
.Qq hide
class)
.Fa tohide
if the object or objects at construction are empty.
.El
.Pp
Applicable element labels (class names) are as follows, letting
.Qq foo
be the name of a structure in the
.Ar config
and
.Qq xxxx
be any of its fields.
.Bl -tag -width Ds -offset indent
.It Li foo-xxxx-bits-checked
Sets or unsets the
.Li checked
attribute depending upon whether the input's
.Li value
attribute (if found) is covered by the object's bitmask.
Only applicable to bit types.
.It Li foo-xxxx-date-text
Replaces the contents of the element with the ISO 8601 date of the
object's value.
Only applicable to date and epoch types.
.It Li foo-xxxx-date-value
Sets the
.Li value
attribute to the ISO 8601 date of the object's value.
Only applicable to date and epoch types.
.It Li foo-xxxx-enum-select
All
.Li <option>
descendents of the element are marked as
.Qq selected
or not depending upon whether their value matches the field value.
.It Li foo-xxxx-obj
For structures, creates and invokes the
.Fn fillInner
method on the nested structure at the given element and its descendents.
This is only applicable for structure types.
.It Li foo-xxxx-text
Replaces the contents of the element with the field value.
This is not applicable to blob native types.
.It Li foo-xxxx-value
Sets the
.Li value
attribute (as in a form submission) with the field value.
This is not applicable to blob native types.
.It Li foo-xxxx-value-checked
Sets or unsets the
.Li checked
attribute depending upon whether the input's
.Li value
attribute matches the objects.
This is not applicable to blob or structure types.
.It Li foo-has-xxxx
Remove the
.Dq hide
class if the object is null, otherwise add the
.Dq hide
class.
.It Li foo-no-xxxx
Add the
.Dq hide
class if the object is null, otherwise remove the
.Dq hide
class.
.El
.Ss Static Members
Each enumeration class contains static members with the numeric value of
its items.
.Pp
Each bitfield class contains two static members per item: one for the
bit index, one for the generated bit mask.
The former is prefixed
.Li BITI_ ,
the latter with
.Li BITF_ .
Thus an item
.Qq foo
creates numeric static members
.Va BITI_foo
and
.Va BITF_foo .
There is always a
.Va BITI__MAX
that is one greater than the largest item's value.
.Ss Static Methods
Each enumeration corresponds to a class with field values and formatting
static methods.
These take advantage of the
.Cm jslabel
enumeration label described in
.Xr ort 5 .
.Bl -tag -width Ds -offset indent
.It Fn format "e" "name" "value"
Fills in all elements (not inclusive) descending from
.Fa e
having class
.Fa name Ns "-label"
with the configuration label corresponding to the enumeration value
.Fa value .
If
.Fa name
is
.Dv null ,
the element itself has its contents filled in.
It
.Fa value
is
.Dv null
or not a valid enumeration value, the empty string is filled in.
.El
.Pp
If a language is specified in the root of the HTML or XML document with
the
.Qq lang
attribute, it is first matched a label for that language.
If there is no language, or none for that label, the default label is
used.
If there is no default label, an empty string is used instead.
.Pp
Bit-fields behave similarly and have the same member.
.Bl -tag -width Ds -offset indent
.It Fn format "e" "name" "value"
Fills in all elements (not inclusive) descending from
.Fa e
having class
.Fa name Ns "-label"
with all configuration labels with corresponding bits set in
.Fa value .
If
.Fa name
is
.Dv null ,
the element itself has its contents filled in.
It
.Fa value
is
.Dv null ,
the
.Qq ort-null
class is added and the
.Cm isnull
label is used.
If not specified, an empty string is used.
If
.Fa value
is zero, the
.Qq ort-unset
class is added and the
.Cm isunset
label is used.
If not specified, an empty string is used.
.El
.Ss Customisation
All functions accept an optional argument for providing custom per-field
or per-structure callbacks.
Keys in the object must consist of the structure name, followed by a
dash, followed by the field name.
For example, assuming a structure
.Dq client
with a field
.Dq dob
consisting of a UNIX epoch:
.Bd -literal -offset indent
const custom: DataCallbacks = { 'client-dob': formatDate };
new ort.client(obj).fillInner(document.body, custom);
.Ed
.Pp
And letting a formatting function be:
.Bd -literal -offset indent
function formatDate(e: HTMLElement,
  name: string, v: number|null): void {
    /* Do something... */
}
.Ed
.Pp
The same can be applied to structures instead of to fields within
structures.
The keys for these are simply the structure name.
.Bd -literal -offset indent
const custom: DataCallbacks = { 'client': formatClient };
new ort.client(obj).fillInner(document.body, custom);
.Ed
.Pp
The callback will then be provided the full client object.
.Pp
In either case, the value for the custom key may also be an array of
functions just as above.
Each will be invoked in the order given, in the same way.
.Bd -literal -offset indent
const custom: DataCallbacks = {
    'client': [ format1, format2 ]
};
.Ed
.Pp
The callback function (or functions) will be invoked regardless of
whether the value has been set.
In the event of an unset field value, the function is passed
.Dv null .
.Pp
For example, to fill in the label of an enumeration
.Li enum someenum
on a field named
.Li val ,
provide a custom callback.
.Bd -literal -offset indent
let e: HTMLElement|null = document.getElementById('foo');
readonly obj: fooData = <fooData>JSON.parse(response);
const custom: DataCallbacks = {
    'foo-val': ort.someenum.format
};
if (e !== null)
    new ort.foo(obj).fill(e, custom);
.Ed
.\" The following requests should be uncommented and used where appropriate.
.\" .Sh CONTEXT
.\" For section 9 functions only.
.\" .Sh RETURN VALUES
.\" For sections 2, 3, and 9 function return values only.
.\" .Sh ENVIRONMENT
.\" For sections 1, 6, 7, and 8 only.
.\" .Sh FILES
.Sh EXIT STATUS
.Ex -std
.Sh EXAMPLES
Start with a means to contact a CGI script producing JSON data formatted
by the
.Fn json_xxxx
family of
.Xr ort-c-header 1 .
This does not do any error checking.
.Bd -literal -offset indent
function init(): void
{
  let xmh: XMLHttpRequest = new XMLHttpRequest();
  xmh.onreadystatechange = function(){
    let v: string = xmh.responseText;
    if (xmh.readyState === 4 && xmh.status === 200)
        success(v);
  };
  xmh.open('GET', 'https://your-cgi-script, true);
  xmh.send(new FormData(form));
}
.Ed
.Pp
Now define
.Fn success
to parse the JSON response content using the classes and methods defined
in the output of
.Nm .
.Bd -literal -offset indent
function success(resp: string): void
{
    let obj: ort.fooData =
        <ort.fooData>JSON.parse(resp);
    new ort.foo(obj).fill(document.getElementById('place'));
}
.Ed
.Pp
Lastly, use the following abbreviated HTML in which to display the
contents of these objects.
Let
.Pa driver.js
consist of the AJAX snippet and formatter and
.Pa foo.s
be the output of
.Nm .
.Bd -literal -offset indent
<!DOCTYPE html>
<html lang="en">
    <head>
      <title>Example</title>
      <script src="foo.js"></script>
      <script src="driver.js"></script>
    </head>
    <body>
        <div id="place">
            <span class="foo-xxxx-text>
                Replaced by the "text" field.
            </span>
        </div>
    </body>
</html>
.Ed
.Pp
Finally, to drive the script, cause
.Fn init
to be invoked when the page has loaded.
This may be in
.Pa driver.js
or directly in the document header.
.Bd -literal -offset indent
window.addEventListener('load', init);
.Ed
.\" .Sh DIAGNOSTICS
.\" For sections 1, 4, 6, 7, 8, and 9 printf/stderr messages only.
.\" .Sh ERRORS
.\" For sections 2, 3, 4, and 9 errno settings only.
.Sh SEE ALSO
.Xr ort-c-header 1 ,
.Xr ort-c-source 1 ,
.Xr ort 5
.\" .Sh STANDARDS
.\" .Sh HISTORY
.\" .Sh AUTHORS
.\" .Sh CAVEATS
.Sh BUGS
This most significant issue with JavaScript and
.Nm
is that of JSON/JavaScript incompatibility.
In
.Nm ,
as exported in JSON, all integers are signed and 64 bits.
JavaScript (and of course TypeScript) encode integers as double
precision floats, which leave than 64 bits of precision.
Therefore, it's very possible to transmit valid numbers and have them be
truncated by JavaScript interpreters.
.Pp
There is as yet no simple way to protect against this.
While some aspects (like enumeration values) may be limited to 32 bits,
raw data emitted by the system is prone to truncation.
