.\"	$OpenBSD$
.\"
.\" Copyright (c) 2020 Kristaps Dzonsons <kristaps@bsd.lv>
.\"
.\" Permission to use, copy, modify, and distribute this software for any
.\" purpose with or without fee is hereby granted, provided that the above
.\" copyright notice and this permission notice appear in all copies.
.\"
.\" THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
.\" WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
.\" MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
.\" ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
.\" WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
.\" ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
.\" OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
.\"
.Dd $Mdocdate$
.Dt ORT-NODEJS 1
.Os
.Sh NAME
.Nm ort-nodejs
.Nd generate node.js module
.Sh SYNOPSIS
.Nm ort-nodejs
.Op Ar config...
.Sh DESCRIPTION
Accepts
.Xr ort 5
.Ar config
files, defaulting to standard input,
and generates a Node module in TypeScript.
.Em This is still experimental.
.Pp
The output requires only the
.Qq typescript
and
.Qq better-sqlite3
dependencies.
The output is documented using the
.Xr typedoc 1
language.
.Ss Module
A
.Nm
context is initialised using the
.Fn ort "dbname: string" Ns No : ortdb
function from the application as follows.
.Bd -literal -offset indent
const db: ortdb = ort('path/to/data.db');
.Ed
.Pp
The
.Pa path/to/data.db
must be an existing SQLite3 database usually created with
.Xr ort-sql 1 .
There should be one
.Vt ortdb
module instanced per application.
It has the following members:
.Bl -tag -width Ds
.It Fn connect Ns No : ortctx
Connect to the database.
This should be invoked for each request.
In applications not having a request, this corresponds to a single
operator sequence.
.It Va version Ns No : string
The version of
.Nm
used to create the module.
.It Va vstamp Ns No : number
The numeric version of
.Nm
used to create the module.
.El
.Pp
Database manipulation occurs with
.Vt ortctx
objects, which consist of the following:
.Bl -tag -width Ds
.It Fn db_role "newrole: string" Ns No : void
If roles are enabled, move from the current role to
.Fa newrole .
If the role is the same as the current role, this does nothing.
Roles may only transition to ancestor roles, not descendant roles or
siblings, or any other non-ancestor roles.
The only exception is when leaving
.Qq default
or entering
.Qq none .
This does not return failure: on role violation, it invokes
.Fn process.abort .
.It Fn db_role_open_current "id: number" Ns No : string
If roles are enabled, get the currently-assigned role.
If
.Fn db_role
hasn't yet been called, this will be
.Qq default .
Throws an exception on database error.
.It Fn db_trans_open_immediate "id: number" Ns No : void
Open a transaction with a unique identifier
.Fa id .
This is the preferred way of creating database transactions.
The transaction immediately enters unshared lock mode (single writer,
readers allowed).
Throws an exception on database error.
.It Fn db_trans_open_deferred "id: number" Ns No : void
Open a transaction with a unique identifier
.Fa id .
The transaction locks the database on first access with shared locks (no
writes allowed, reads allowed) on queries and unshared locks (single
writer, reads allowed) on modification.
Throws an exception on database error.
.It Fn db_trans_exclusive "id: number" Ns No : void
Open a transaction with a unique identifier
.Fa id .
The transaction locks exclusively, preventing all other access.
Throws an exception on database error.
.It Fn db_trans_commit "id: number" Ns No : void
Commit a transaction opened by
.Fn db_trans_open_immediate ,
.Fn db_trans_open_deferred ,
or
.Fn db_trans_open_exclusive
with identifier
.Fa id .
Throws an exception on database error.
.It Fn db_trans_rollback "id: number" Ns No : void
Roll-back a transaction opened by
.Fn db_trans_open_immediate ,
.Fn db_trans_open_deferred ,
or
.Fn db_trans_open_exclusive
with identifier
.Fa id .
Throws an exception on database error.
.El
.Ss Data access
Each structure has a number of operations available in
.Vt ortctx .
These are all stipulated as
.Cm count ,
.Cm delete ,
.Cm insert ,
.Cm iterate ,
.Cm list ,
.Cm search ,
and
.Cm update
statements in the configuration.
Let
.Qq foo
be the name of the exemplar structure.
All of these functions will throw an exception on database error.
.Bl -tag -width Ds
.It Fn "db_foo_delete_xxxx" "ARGS" Ns No : void
Run the named
.Cm delete
function
.Qq xxxx .
The
.Fa ARGS
passed to this function are the fields that constrain which rows are
deleted.
Parameters are only specified for operations for binary-operator
constraints, i.e., those not checking for null status.
.It Fn "db_foo_delete_by_yy_op" "ARGS" Ns No : void
Like
.Fn db_foo_delete_xxxx ,
but using an un-named
.Cm delete
statement constrained by
.Qq yy
with operation
.Qq op .
.It Fn "db_foo_get_xxxx" "ARGS" Ns No : ortns.foo|null
The
.Cm search
statement named
.Qq xxxx .
The function accepts variables for all binary-operator fields to check
(i.e., all except for those checking for null).
.It Fn "db_foo_get_by_xxxx_op1_yy_zz_op2" "ARGS" Ns No : ortns.foo|null
Like
.Fn db_foo_get_xxxx ,
but for (possibly-nested) structures.
In the given example,
.Qq xxxx
is a field in the given structure with operation
.Qq op1
and
.Qq yy_zz
means a field
.Qq zz
in the nested structure
.Qq yy
with operation
.Qq op2 .
.It Fn "db_foo_insert" "ARGS" Ns No : BigInt
Insert a row and return its identifier or -1 on constraint failure.
This accepts all native fields
.Fa ARGS
as parameters excluding
.Cm rowid ,
which is automatically set by the database.
If any fields are specified as
.Cm null ,
they are passed into this functions as pointers.
The null values must then be specified as
.Dv NULL
pointers.
This function is only generated if the
.Cm insert
statement is specified for the given structure.
.It Fn "db_foo_iterate" "ARGS" "cb" Ns No : void
Like
.Fn db_foo_iterate_xxxx
but iterating over all rows.
.It Fn "db_foo_iterate_xxxx" "ARGS" "cb" Ns No : void
Like
.Fn db_foo_get_xxxx ,
but invoking a function callback per row.
The
.Fa cb
callback accepts a single parameter of type
.Vt ortns.foo
and does not have a return value.
.It Fn "void db_foo_iterate_by_xxxx_op1_yy_zz_op2" "ARGS" "cb" Ns No : void
Like
.Fn db_foo_get_by_xxxx_op1_yy_zz_op2 ,
but invoking a function callback for each retrieved result.
.It Fn "db_foo_count" Ns No : BigInt
Like
.Fn db_foo_count_xxxx
but returning a count of all rows.
.It Fn "db_foo_count_xxxx" "ARGS" Ns No : BigInt
Like
.Fn db_foo_get_xxxx ,
but returning a count of responses.
.It Fn "db_foo_count_by_xxxx_op1_yy_zz_op2" "ARGS" Ns No : BigInt
Like
.Fn db_foo_get_by_xxxx_op1_yy_zz_op2 ,
but returning a count of responses.
.It Fn "db_foo_list" Ns No : ortns.foo[]
Like
.Fn db_foo_list_xxxx
but allocating and filling a queue of all rows.
.It Fn "db_foo_list_xxxx" "ARGS" Ns No : ortns.foo[]
Like
.Fn db_foo_get_xxxx ,
but producing an array of responses.
.It Fn "db_foo_list_by_xxxx_op1_yy_zz_op2" "ARGS" Ns No : ortns.foo[]
Like
.Fn db_foo_get_by_xxxx_op1_yy_zz_op2 ,
but producing a queue of responses.
.It Fn "db_foo_update_xxxx" "ARGS" Ns No : boolean
Run the named update function
.Qq xxxx .
The update functions are specified with
.Cm update
statements.
The parameters passed to this function are first the fields to modify,
then the fields that constrain which rows are updated.
Update fields are only specified for operations for binary-operator
constraints, i.e., those not checking for null status.
Returns true on success, false on constraint failure.
.It Fn "db_foo_update_xx_mod_by_yy_op" "ARGS" Ns No : boolean
Like
.Fn db_foo_update_xxxx ,
but using an un-named update statement modifying
.Qq xx
with modifier
.Qq mod
constrained by
.Qq yy
with operation
.Qq op .
Either or both modifiers and constraints may be empty.
If modifiers are empty, all fields are modified by setting.
If constraints are empty, they and the preceding
.Qq by
are omitted.
.El
.Pp
The data objects returned by these functions are in the
.Vt ortns
namespace and are named as in the configuration.
Letting
.Qq foo
be an exemplar structure name, the object consists of the following.
.Bl -tag -width Ds
.It Fa "obj" Ns No : ortns.fooData
The read-only data itself.
.It Fn "export" Ns No : any
Create an exportable object.
Export rules are governed by the role in which the object was created.
This is usually used with
.Fn JSON.stringify
to output JSON objects.
.El
.Pp
The exported object, when converted into a string, is readable by
applications using the
.Xr ort-javascript 1
tool.
.Ss Data structures
Assuming the exemplar structure
.Qq foo ,
the data in
.Sx Data access
may be manipulated with the
.Vt ortns.fooData obj
object interface in
.Vt ortns.foo .
This consists of all fields in the structure with types mapped as follows:
.Bl -column -offset indent "password " "Buffer "
.It Cm bit Ta BigInt
.It Cm date Ta BigInt
.It Cm epoch Ta BigInt
.It Cm int Ta BigInt
.It Cm real Ta number
.It Cm blob Ta Buffer
.It Cm text Ta string
.It Cm email Ta string
.It Cm password Ta string
.It Cm bits Ta BigInt
.El
.Pp
Structures are mapped to their interfaces, such as
.Va ortns.barData
for a structure named
.Qq bar .
Enumerations are mapped to enumerations defined similarly, such as
.Va ortns.baz
for an enumeration named
.Qq baz .
The enumeration values are all string literals of their numeric value.
.Pp
If a field is marked as
.Cm null ,
it will also be given the
.Vt null
type.
.\" The following requests should be uncommented and used where appropriate.
.\" .Sh CONTEXT
.\" For section 9 functions only.
.\" .Sh RETURN VALUES
.\" For sections 2, 3, and 9 function return values only.
.\" .Sh ENVIRONMENT
.\" For sections 1, 6, 7, and 8 only.
.\" .Sh FILES
.Sh EXIT STATUS
.Ex -std
.Sh EXAMPLES
The following example is a full web-server running on port 3000 using
the Node framework.
It uses the
.Qq express ,
framework for web requests,
.Qq bcrypt
for passwords, and
.Qq better-sqlite3
for the database.
It mandates the use of TypeScript instead of JavaScript.
It needs only the
.Xr npm 1
system installed and (depending on the operating system) a C/C++
compiler for
.Qq better-sqlite3 .
.Pp
Begin a project (if not already begun) as follows:
.Bd -literal -offset indent
% cd myproject
% npm init -y
% npm install typescript better-sqlite3 express bcrypt
% npm install @types/express @types/bcrypt @types/better-sqlite3
% npx tsc --init
.Ed
.Pp
If installing
.Qq better-sqlite3
or
.Qq bcrypt
on
.Ox ,
you may need to specify an alternate compiler:
.Bd -literal -offset indent
% CXX=/usr/local/bin/clang++ \e
  CC=/usr/local/bin/clang \e
  npm install better-sqlite3 bcrypt
.Ed
.Pp
Modify
.Pa package.json
to mandate the use of TypeScript instead of JavaScript:
.Bd -literal -offset indent
[...]
"main": "index.ts",
"scripts": {
  "test": "echo \e"Error: no test specified\e" && exit 1",
  "tsc": "tsc"
}
[...]
.Ed
.Pp
Next, modify
.Pa tsconfig.json
to use a more up-to-date output type for JavaScript, otherwise many
TypeScript security idioms will not be available.
.Bd -literal -offset indent
"target": "es2015",
.Ed
.Pp
Now use the following toy
.Xr ort 5
configuration installed as
.Pa myproject.ort :
.Bd -literal -offset indent
roles {
  role user;
};
struct user {
  field name text;
  field id int rowid;
  insert;
  search id: name id;
  roles default { all; };
};
.Ed
.Pp
Compile the configuration as a module:
.Bd -literal -offset indent
% mkdir modules
% ort-nodejs myproject.ort > modules/ort.ts
.Ed
.Pp
Use the following simple application:
.Bd -literal -offset indent
import express, { Request, Response } from 'express';
import { ort, ortns, ortctx, ortdb } from './modules/ort';

const app = express();
const db: ortdb = ort('test.db');

app.get("/put", function(req: Request, res: Response) {
  const ctx: ortctx = db.connect();
  const id: BigInt = ctx.db_user_insert('name');
  res.send(id.toString());
});

app.get("/get", function(req: Request, res: Response) {
  const ctx: ortctx = db.connect();
  const obj: ortns.user|null =
    ctx.db_user_get_id(BigInt(1));
  if (obj !== null)
    res.send(JSON.stringify(obj.export()));
  else
    res.send('not found');
});

app.listen(3000, function() {
  console.log('Server is running.');
});
.Ed
.Pp
Compile the application.
This will create
.Pa index.js .
.Bd -literal -offset indent
% npm run tsc
.Ed
.Pp
Make sure that the database exists.
This should only be run once.
.Bd -literal -offset indent
% ort-sql db.ort | sqlite3 test.db
.Ed
.Pp
Lastly, run the project itself:
.Bd -literal -offset indent
% node index.js
Server is running.
.Ed
.Pp
Making an HTTP request to
.Qq localhost:3000
will result in a display of the created user's identifier.
.\" .Sh DIAGNOSTICS
.\" For sections 1, 4, 6, 7, 8, and 9 printf/stderr messages only.
.\" .Sh ERRORS
.\" For sections 2, 3, 4, and 9 errno settings only.
.Sh SEE ALSO
.Xr node 1 ,
.Xr npm 1 ,
.Xr ort 5
.\" .Sh STANDARDS
.\" .Sh HISTORY
.\" .Sh AUTHORS
.\" .Sh CAVEATS
.\" .Sh BUGS
